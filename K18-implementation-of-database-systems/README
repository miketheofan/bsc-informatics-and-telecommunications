Ονοματεπώνυμο: Θεοφανόπουλος Μιχαήλ , Δημησιάνος Σπυρίδων
Αριθμός Μητρώου: 111 520 18 00 053 , 111 520 18 00 042
1η & 2η Εργασία Υλοποίηση Συστημάτεων Βάσεων Δεδομένων 2023

-> Οι εντολές του makefile που απαιτούνται ώστε να τρέξουν και τα 3 εκτελέσιμα έχουν παραμείνει όμοιες με αυτές που μας δόθηκαν στην εκφώνηση της εργασίας.

*********************
*		 HP         *
*********************

-> Για την δομή HP_info επιλέξαμε να διατηρούμε τον file descriptor και το block entries, με σκοπό να δίνεται σαν όρισμα σε όσες συναρτήσεις απαιτείται και να διατηρείται η πληροφορία κατά την εκτέλεση του προγράμματος.

-> Κατά τη δημιουργία ενός heap file διατηρούμε ένα μοναδικό αναγνωριστικό "hp" , ώστε να ελέγχεται κατάλληλα ότι το block αφορά ένα heap file.

-> Όλα τα blocks που γράφονται μαρκάρονται ως dirty και όλα τα blocks που δε χρειάζονται πλέον γίνονται unpin.

-> Όλες οι δομές BF_Block που δεσμεύονται, αποδεσμεύονται κανονικά, όπως και κάθε τμήμα μνήμης που δεσμεύεται δυναμικά εν ώρα εκτέλεσης.

-> Για την εισαγωγή ενός record, προσθέτουμε στη μνήμη κάθε πεδίο του σειριακά στις θέσεις μνήμης που του αναλογούν.

-> Για τον υπολογισμό του Block Cap κάναμε define μια inline function στο αρχείο hp_file.h.

-> Η main συνάρτηση καθώς και η χρήση της παρέμεινε όπως το πρότυπο που μας δώθηκε μαζί με την εκφώνηση.

-> Στη συνάρτηση HP_GetAllEntries γίνεται έλεγχος για το αν έχει δωθεί specific value το οποίο θα πρέπει να ψαχτεί, διαφορετικά δίνεται ως παράμετρος PRINT_ALL και επιστρέφονται όλα τα entries.

***********************
*		  HT          *
***********************

-> Για τη δομή HT_info επιλέξαμε να διατηρούμε το όνομα του αρχείου, τον file descriptor, τον αριθμό από buckets και τη τοποθεσία του τελευταίου record, με σκοπό να δίνεται σαν όρισμα σε όσες συναρτήσεις απαιτείται και να διατηρείται η πληροφορία κατά την εκτέλεση του προγράμματος.

-> Για τη δομή HT_block_info επέλεξα να διατηρώ ένα string τριών χαρακτήρων το οποίο αναπαριστά το id που ξεχωρίζει ότι η συγκεκριμένη δομή αφορά το ht μας.

-> Το πρώτο μπλοκ κάθε αρχείου περιέχει το αναγνωριστικό "hp", το οποίο χρησιμοποιείται για τον έλεγχο του εάν ένα block file αποτελεί heap file και έναν ακέραιο που αναπαριστά το πλήθος των buckets του hashtable.

-> Τα επόμενα μπλοκ ξεκινώντας από το δεύτερο χρησιμεύουν για την αποθήκευση του
hashtable και γίνονται allocated στη συνάρτηση HT_OpenFile.

-> Όλα τα μπλοκ του Hash Table δεσμεύονται στη συνάρτηση HT_CreateIndex().

-> Σε κάθε μπλοκ δεδομένων εισάγεται το record και η ακριβής τοποθεσία στη μνήμη όπου εισάγεται υπολογίζεται με βάση τη θέση του μπλοκ όπου πρέπει να μπει και το πόσα records υπάρχουν ήδη στο μπλοκ αυτό.

-> Όλα τα blocks στα οποία γίνεται κάποια εισαγωγή μαρκάρονται ως dirty και όλα τα blocks που δε χρειάζονται πλέον γίνονται unpin.

-> Για τη εκτύπωση των entries, εάν δωθεί NULL σαν value τότε εκτυπώνουμε όλα τα records που υπάρχουν στη μνήμη. Διαφορετικά, υπολογίζουμε τη τοποθεσία του block στο οποίο βρίσκεται το record με value ίσον με αυτό που ψάχνουμε (blockOld), ύστερα ανατρέχουμε όλα τα blocks(blockNew) μέσα στο bucket μέχρι να βρούμε αυτό που ψάχνουμε και το εκτυπώνουμε.

***********************
*		  SHT         *
***********************

-> Για τη δομή SHT_info επέλαξα να διατηρώ το όνομα του αρχείου πρωτεύοντος κατακερματισμού, το όνομα του αρχείου δευτερεύοντος κατακερματισμού, τον file descriptor, τον αριθμό από buckets, τη τοποθεσία του τελευταίου record, τον συνολικό αριθμό από blocks που υπάρχουν και το dictionary στο οποίο θα αποθηκεύονται τα ονόματα με σκοπό να δίνεται σαν όρισμα σε όσες συναρτήσεις απαιτείται και να διατηρείται η πληροφορία κατά την εκτέλεση του προγράμματος.

-> Η διαδικασία που ακολουθείται για το SHT είναι σχεδόν ίδια με τη διαδικασία που ακολουθείται για το HT. Ο τρόπος που μπαίνουν όλα τα blocks στη μνήμη είναι ο ίδιος.

-> Η κύρια διαφοροποίηση είναι ότι διατηρώ μια δική μου δομή Dictionary η οποία είναι μια λίστα και χρησιμοποιείται για να αποθηκεύει τα ονόματα όλων των records διατηρώντας τα coordinates της (bucket στο οποίο βρίσκεται και θέση του μέσα στο bucket) με σκοπό κατά τη διαδικασία της αναζήτησης να μην χρειάζεται να κάνουμε access τη μνήμη πολλές φορές παρά μόνο για όσα blocks έχουν όνομα ίδιο με το όνομα που μας δίνεται σαν όρισμα.

-> Κατά τη διαδικασία της εισαγωγής δίνεται σαν όρισμα στην SHT_SecondaryInsertEntry το block_id το οποίο επιστρέφεται από την HT_InsertEntry και είναι στην ουσία το block στο οποίο εισήχθη το record. Με αυτόν τον τρόπο εισάγεται κατευθείαν στο σωστό μέρος μέσα στη μνήμη για το SHT.

***********************
*	    ΓΕΝΙΚΑ        *
***********************

-> Όλες οι δομές BF_Block που δεσμεύονται, αποδεσμεύονται κανονικά, όπως και κάθε τμήμα μνήμης που δεσμεύεται δυναμικά εν ώρα εκτέλεσης.

-> Για τον έλεγχο όλων των εκτελέσιμων χρησιμοποίησα τις αντίστοιχες main συναρτήσεις όπως μας δώθηκαν και έκανα τις εξής αλλαγές:
	1) Άλλαξα το srand(time(NULL)), ώστε να παράγει κάθε φορά διαφορετικό value.
	2) Για λόγους testing τόσο για εμένα όσο και για τον διορθωτή έβαλα δυο εντολές για την εκτύπωση μία να εκτυπώνει όλα ta records και μια ένα συγκεκριμένο.

-> Για το return type που επιστρέφουν η πλειοψηφία των συναρτήσεων σε όλα τα εκτελέσιμα δημιούργησα τα αντίστοιχα enum HP_ErrorCode/HT_ErrorCode/SHT_ErrorCode τα οποίο περιλαμβάνουν τις αντίστοιχες τιμές OK και ERROR.

-> Όλα τα εκτελέσιμα αρχεία περιέχουν σχόλια τα οποία είναι επαρκή για την πλήρη περιγραφή του κώδικα.